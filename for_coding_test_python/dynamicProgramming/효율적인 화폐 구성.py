# 효율적인 화폐 구성

# N가지 종류의 화폐가 있습니다. 이 화폐들의 개수를 최소한으로 이용해서 그 가치의 합이 M원이 되도록 하려고 합니다.
# 이 때 각 종류의 화폐는 몇 개라도 사용할 수 있습니다.
# 예를 들어 2원, 3원 단위의 화폐가 있을 때는 15원을 만들기 위해 3원을 5개 사용하는 것이 가장 최소한의 화폐 개수입니다.

# M원을 만들기 위한 최소한의 화폐 개수를 출력하는 프로그램을 작성하세요.

# 입력 조건
# 첫째 줄에 N, M이 주어진다
# 이후의 N개의 줄에는 각 화폐의 가치가 주어진다. 화폐의 가치는 10,000보다 작거나 같은 자연수이다.

# 입력 예시1
# 2 15
# 2
# 3

# 입력 예시2
# 3 4
# 3
# 5
# 7

# 출력 조건
# 첫째 줄에 최소 화폐 개수를 출력한다.
# 불가능할 때는 -1을 출력한다.

# 출력 예시1
# 5

# 출력 예시2
# -1


# 나의 답안

# N, M = map(int, input().split())
# input_list = []
# for i in range(N):
#     item = int(input())
#     input_list.append(item)

# # input_list 내림차순 정렬
# input_list.sort(reverse=True)

# # DP 테이블 초기화
# d = [0] * (10000+1)

# count = 0
# # 다이나믹 프로그래밍 진행 ( 보텀업 )
# while 1:
#     first = 0
#     k = input_list[first]
#     if M % k == 0:
#         count += 1
#         M = M // k
#     else:
#         if first <= len(input_list):
#             first += 1
#         else:
#             pass

#     if M == 1:
#         break

# if count == 0:
#     count = -1

# print(count)


# 정답안

# 문제 해결 아이디어
# Ai = 금액 i를 만들 수 있는 최소한의 화폐 개수
# k = 각 화폐의 단위
# 점화식: 각 화폐 단위인 k를 하나씩 확인하며
    # A(i-k)를 만드는 방법이 존재하는 경우, Ai = min(Ai, A(i-k)+1)
    # A(i-k)를 만드는 방법이 존재하지 않는 경우, Ai = INF

# 예를 들어 N=3, M=7이고, 각 화폐의 단위가 2,3,5인 경우를 확인해 봅시다
# Step0. 초기화
#   먼저 각 인덱스에 해당하는 값으로 INF(무한)의 값을 설정함
#   INF은 특정 금액을 만들 수 있는 화폐 구성이 가능하지 않다는 의미를 가짐
#   본 문제에서는 10,001을 사용할 수 있음
#   인덱스: 0 1 2 3 4 5 6 7
#   값: 0 10,001 10,001 10,001 10,001 10,001 10,001 10,001

# Step1.
#   첫 번째 화폐 단위인 2를 확인합니다.
#   점화식에 따라 다음과 같이 리스트가 갱신됩니다.
#   인덱스: 0 1 2 3 4 5 6 7
#   값: 0 10,001 1 10,001 2 10,001 3 10,001

# Step2.
#   두 번째 화폐 단위인 3을 확인합니다.
#   점화식에 따라서 다음과 같이 리스트가 갱신됩니다.
#   인덱스: 0 1 2 3 4 5 6 7
#   값: 0 10,001 1 1 2 2 2 3

# Step3.
#   세 번째 화폐 단위인 5를 확인합니다.
#   점화식에 따라서 다음과 같이 최종적으로 리스트가 갱신됩니다.
#   인덱스: 0 1 2 3 4 5 6 7
#   값: 0 10,001 1 1 2 1 2 2

# 정수 N, M을 입력 받기
N, M = map(int, input().split())

# N개의 화폐 단위 정보를 입력 받기
array = []
for i in range(N):
    array.append(int(input()))

# 한 번 계산된 결과를 저장하기 위한 DP 테이블 초기화
d = [10001] * (M+1)

# 다이나믹 프로그래밍(Dynamic Programming) 진행 (보텀업)
d[0] = 0
for i in range(N):
    for j in range(array[i], M+1):
        if d[ j-array[i] ] != 10001: # (i-k)원을 만드는 방법이 존재하는 경우
            d[j] = min(d[j], d[ j-array[i] ] + 1)

# 계산된 결과 출력
if d[M] == 10001: # 최종적으로 M원을 만드는 방법이 없는 경우
    print(-1)
else:
    print(d[M])